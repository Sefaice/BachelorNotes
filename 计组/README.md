* “王道”指王道2020计组复习指导
* “课本”指《计算机组成与设计 软件/硬件接口》
* “唐的课本”指《计算机组成原理》第二版，唐朔飞

## 计算机系统概述

### 发展历程

### 层次结构

冯诺依曼结构，以运算器为中心，存储程序。

现代结构，以存储器为中心。

**MAR和MDR**：MAR存储地址，长度和存储单元个数有关（等于PC）；MDR存储数据，长度等于存储字长。**MAR和MDR属于存储器，但都存在于CPU中**。不论是访存取指令还是数据，都是先将地址传给MAR，访存取出内容放入MDR，结合指令执行过程的数据通路理解。

王道P8选择题1，结构图。控制器和运算器组成CPU，再加上存储器就组成了主机。

### 性能指标

**机器的32位/64位：机器字长，指计算机进行一次整数运算能处理的二进制数据的位数。一般等于内部寄存器的大小**。王道P22，与指令字长和存储字长的区别。

CPI, MIPS。

王道P22，透明性。

## 数据的表示和运算

### 数制与编码

C中二进制`0b`，八进制`0`，十六进制`0x`。

#### 不同进制相互转换

二进制转八进制/十六进制：将每3位（十六进制为4位）二进制数转换成一个八进制数。

十进制转换为其它进制数：整数部分用**除基取余法**，小数部分用**乘基取整法**。

BCD码：Binary-Coded Decimal，二进制编码的十进制数。常用8421码，拿8421码运算时得到大于`1011`时需要加6修正。

大端模式，小端模式：详见CMU课件note1。

边界对齐：CMU课件note1，其实是一种空间换时间的思想，适应指令流水线。

#### 校验码

校验码是能发现或自动纠正错误的数据编码，也叫检错纠错码。原理是通过在原数据码上增加冗余码来达到检错/纠错。

码距：任意两个合法码字之间最少变化的二进制位数（位数，不是差值）。码距>=2时，校验码开始具有检错能力（显而易见）。码距越大，检错、纠错能力越强，且检错能力总是大于纠错能力。

**奇偶校验码**：1位校验位，码距为2，可以检测出奇数位错误（奇数个错误），无法确定错误位置，无法纠正错误。奇校验，偶校验。

**海明码**：默认的，基本的海明码可以检测并纠正1位错误，不论是数据位还是校验位。使用步骤：确定位数（使用`n + k <= 2^k - 1`就限制了这个海明码是只能检测1位的基本海明码） - 确定校验位的位置 - 分组 - 校验位取值 - 校验。

**CRC码**：可以检测并纠正1位错误。使用步骤：生成多项式G的最高次幂为校验位R的位数 - 原信息码左移R位 - **模2除**得到R位余数作为校验位 - 校验。

### 定点数

原码，反码，补码，移码：参考王道，课本P223。

补码大小比较：规则是，符号位相同，数值越大，码值越大。王道P49的21-24题。

#### 定点数移位运算

算术移位：符号位不动，补0或补1，规则是王道P39的表2.1。

逻辑移位：全部移动，全部补0。

循环移位：分为带进位标志位和不带进位标志位。

#### 定点数加减法运算

减法运算将减数取反，化为加法运算。

补码运算溢出判断：看双符号位/进位。

#### 定点数乘除运算

课本P222。

原码一位乘法：符号位单独计算，相当于普通乘法，看被乘数最低位，若为1则结果加乘数并右移。

补码一位乘法（Booth算法）：符号位参与运算，将二进制数拆开化简以减少加法运算次数。

原码除法（不恢复余数法）：符号位单独运算。

补码除法（加减交替法）：符号位参与运算。

**强制类型转换**：见CMU课件note1。C中隐式类型转换的规则是向上提升，即运算时将所有操作数隐式转换为其中最高的类型。

### 浮点数

CMU课件note2。

规格化：看尾数，原码和补码的规则不同，王道P64。尾数溢出时右归，其它格式不合规则都左归。

溢出：看规格化后的阶码是否溢出。

### ALU

一位全加器：和表达式，进位表达式。

并行加法器：G和P的公式。

## 存储系统

### 存储器的分类

按存取方式分类：
* RAM随机存取存储器，断电信息消失（易失性存储器），SRAM做cache，DRAM做主存。
* ROM只读存储器，非易失性存储器。广义上有些派生的ROM存储器已可以写入。
* 串行访问存储器，访问时需按物理位置先后顺序寻址，包括磁盘（DAM直接存取存储器）和磁带（顺序存取存储器）。

### 半导体随机存储器

半导体存储芯片有**读写控制线，片选线，地址线，数据线**等线路，半导体随机存储器一般有SRAM和DRAM。

**引脚/线数目问题**：读写控制线2条；片选线SRAM1条，DRAM2条（行列分别选通）；地址线根据单元数计算，DRAM再乘1/2（地址复用）；数据线看单元长度。王道3.3.4的1、9、10题。

SRAM和DRAM的工作原理：王道P96。

DRAM采用**地址复用**技术，地址线是原来的1/2，地址信号分行、列传送。且DRAM需要不断刷新，有三种刷新方式：
* 集中刷新：集中对所有行依次刷新，存在“死时间”或“死区”，在死区中不能访问存储器。
* 分散刷新：把每行的刷新分散到存储器的工作周期中，工作周期的后半部分用于刷新某一行，这样没有“死区”，但加长了存取周期。
* 异步刷新：在刷新周期中均匀刷新，每隔一定时间刷新一行，存在”死时间“，但比较短。
* 透明刷新：将刷新安排在不访存的译码阶段，不会增长存取周期，也没有”死时间“。

DRAM的刷新对CPU是透明的；刷新单位是行，只需要行地址；刷新没有信息输出；所有芯片同时刷新，不需要选片。

### 主存与CPU连接

位扩展，字扩展。

### 双端口RAM和多模块存储器

#### 双端口RAM

两套独立的数据线、地址线、控制线，支持两个控制器异步访问同一单元。

#### 多模块存储器

单体多字存储器：一个存储单元存储多个字，要求指令和数据必须在存储器连续存放，否则效果不好。

多体并行存储器：高位交叉编址，本质依然是顺序存储器；低位交叉编制，交叉存储器，可用流水线存取，流水线计算（实现流水线最小模块数计算）。

### Cache

时间局部性：最近的未来用到的信息，很可能是正在使用的信息；空间局部性：最近的未来用到的信息，很可能与正在使用的信息在存储空间上是临近的。

#### Cache的基本工作原理

CPU与cache或主存以**字**为单位交换信息，cache与主存以**块**为单位交换信息。

#### Cache和主存的映射方式

主存块和cache块大小相同，主存和cache地址相同，因而进行地址映射（不同的解析方式），地址映射有三种方式：
* 直接映射：`cache块号 = 主存块号 % cache块数(主存块号 = 主存地址 / 块大小)`，地址结构为`tag + cache块地址 + 块内地址`。
* 全相联映射：地址结构为`tag + 块内地址`。
* 组相联映射：`cache组号 = 主存块号 % 组数`，地址结构为`tag + 组地址 + 块内地址`。

**计算cache总容量/总位数**：计算cache内的大小，和cache地址结构不一样。`有效位1位 + 标记位tag + （脏位1位，只有采用写回策略才有） + 数据位（区分数据位数和地址位数`。

#### Cache写策略

命中：全写法（write-through），写回法（write-back）。

未命中：写分配法（write-allocate），非写分配法（no-write-allocate）。

命中和未命中策略的通常搭配：全写法搭配非写分配法，写回法搭配写分配法，流程图如下。

![Write-through_with_no-write-allocation](./imgs/Write-through_with_no-write-allocation.svg)

![Write-back_with_write-allocation](./imgs/Write-back_with_write-allocation.svg)

[图来自wiki](https://en.wikipedia.org/wiki/Cache_(computing))，全写法搭配非写分配法逻辑比较简单，写回法搭配写分配法每次从内存调入新块时需要判断旧cache块是否为dirty，是则要先将旧块写回内存。

### 虚拟存储器

将主存或辅存的地址空间统一编址，具有主存的速度和辅存的容量。

页式虚拟存储器：地址转换过程。页表在主存中，用于虚页号到实页号的转换。发生缺页时，是否是先从辅存调入页，再重新进行页表访问？即一共3次访存？

段式虚拟存储器：地址转换过程。段表存储程序段在主存中的物理地址和段长。

快表（TLB，Translation lookaside buffer）：页表存储与主存中，因此查页表再访存相当于两次访存，因而引入快表，快表存放于cache中。快表根据内容指定地址，一般采用相联存储器实现。

**有虚拟存储器和cache的存储系统的访问顺序**：王道P139。

虚拟存储器和cache的比较：王道P139。

## 指令系统

### 指令格式

基本格式：操作码 + 地址码。

根据指令字长可分为：定长指令字结构和变长指令字结构。在字节编址的机器中，字长一般都是字节的倍数。

根据操作数地址码的数目，可分为：零地址、一地址、二地址、三地址、四地址指令。

#### 操作码指令格式

定长操作码指令格式：操作码位数固定。

扩展操作码指令格式：操作码变长。短操作码不能是长码的前缀，因此n位短码的指令不能完全占用2^n条，要为长码预留，见王道P152例子。

### 指令寻址方式

#### 指令寻址

* 顺序寻址：`(PC) = (PC) + 1`（+1指增加一个指令字长）
* 跳跃寻址：修改(PC)

#### 数据寻址

A表示形式地址，EA指有效地址，(EA)指有效地址的值，即操作数。

* 隐含寻址
* 立即寻址：指令的地址字段存放的是操作数（立即数），用补码表示。
* 直接寻址：`EA = A`
* 间接寻址：`EA = (A)`，需多次访存。
* 寄存器寻址：`EA = R`
* 寄存器间接寻址：`EA = (R)`
* 相对寻址：`EA = (PC) + A`，广泛应用于转移指令。
* 基址寻址：`EA = (BR) + A`，BR是基址寄存器，程序执行时BR不变，A可变。面向操作系统，有利于多道程序设计，可用于编制浮动程序。
* 变址寻址：`EA = (IX) + A`，IX是变址寄存器，程序执行时A不变，IX可由用户改变。面向用户，适合编制循环程序，处理数组。
* 堆栈寻址：寄存器堆栈是硬堆栈，主存划分堆栈是软堆栈。SP堆栈指针是一个特定寄存器，用于给出被读/写单元的地址，即指向栈顶空单元（课后题10）。

王道P162表4.1。做题时注意要求是`有效地址EA`还是`操作数(EA)`

### CISC & RISC

CISC：X86；指令数目多；长度不固定；访存指令不受限制；大多指令需要多个周期执行；大多采用微程序控制；边界对齐不对齐都支持。

RISC：AR、MIPS架构；指令少；长度固定；只有Load/Store指令可以访存，其余指令操作在寄存器间进行，CPU中通用寄存相当多，以减少访存次数；**一定采用指令流水线技术**，大部分指令在一个周期完成；以硬布线控制为主；边界对齐。

## 中央处理器

## 总线

## 输入/输出系统
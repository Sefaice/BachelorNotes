* “王道”指王道2020数据结构复习指导

## 绪论

区分**数据的逻辑结构和存储结构**。

逻辑结构：
* 线性结构：
  * 一般线性表
  * 受限线性表：栈、队列
  * 线性表推广：数组、广义表
* 非线性结构：
  * 集合
  * 树形结构
  * 图或网

存储结构/物理结构：
* 顺序存储
* 链式存储
* 索引存储
* 散列存储/哈希

时间复杂度：算法中基本语句（最内层循环语句）执行次数的数量级，O表示数量级。

空间复杂度：算法消耗的辅助空间的数量级，O(1)表示算法原地工作，指算法需要的辅助空间为常量。

**分析时间复杂度的方法**：
* 若循环主体中的变量参与循环条件的判断：将变量代入循环条件计算
* 若循环主题变量与循环条件无关：
  * 程序是递归的：递推
  * 程序非递归：累次求和

## 线性表

### 线性表的定义和基本操作

线性表是具有相同数据类型n个元素的**有限**序列。线性表中元素有先后顺序。

### 线性表的顺序表示

即线性表这个逻辑结构的顺序存储方式，又叫顺序表。即数组。

基本操作：
* 插入：将所有后面元素向后移，平均时间复杂度为`O(n)`
* 删除：平均时间复杂度`O(n)`
* 按值查找/顺序查找：平均时间复杂度`O(n)`

**CODING**：王道2.2的3，8，11，12，13。

### 线性表的链式表示

头指针和头结点：头结点让对链表所有结点的操作统一，而头指针在有头结点时指向头结点，没有头结点时指向第一个数据结点。

单链表基本操作：
* 创建链表：头插法或尾插法，时间复杂度都是`O(n)`
* 按序号查找：即访问第i个结点，时间复杂度`O(n)`
* 按值查找：时间复杂度`O(n)`
* 插入：若不包含查找（给定插入位置的前一结点指针），时间复杂度`O(1)`
* 删除：若不包含查找，时间复杂度`O(1)`。另，若给定一结点指针要删除它，不必从头查找它的前一结点，可通过复制后一结点值再删除后一结点实现。

双链表。

循环链表。

静态链表：用数组描述链表，结点的next字段存储的是下一结点的数组下标。

顺序或链式存储的查找时，要区分**按值查找**和**按序号查找**（王道p34）。

**CODING**：王道2.3的5，22。

## 栈和队列

首先，栈和队列属于逻辑结构中的线性表。

### 栈

栈的实现：
* 顺序存储结构：
  * 顺序栈
  * 共享栈：两个栈底分别在共享空间的两端，当栈顶指针相邻时栈满，可以降低上溢可能。
* 链式存储结构

**Catlan卡特兰数**：n个元素以固定顺序进栈，进栈过程中可以出栈，共有不同出栈序列的个数为

```
C(2n, n) / (n + 1)
```

采用分治递归的思想，设第k个元素固定在第k位出栈，它分割前后两组元素的顺序个数也分别独立是卡特兰数。王道p63选择11，25。

### 队列

队头：删除元素的一端；队尾：插入元素的一端。注意是从队尾入队的。

队列的顺序存储：可能出现**上溢出**，数组中仍有空间但两个指针都指向数组末尾。为避免上溢出的缺点，引入了循环队列。

#### **循环队列**

循环队列的关键操作的描述按照王道来，但考题会很严格地给出，不一定按王道。

初始状态：`Q.front = Q.rear = 0`

队列长度：`(Q.rear - Q.front + MaxSize) % MaxSize`

出队入队：`Q.rear = (Q.rear + 1) % MaxSize; //入队 Q.front = (Q.front + 1) % MaxSize // 出队`，两个指针都按顺时针方向进1。

判断队空：`Q.front == Q.rear`，即两个指针重合。

判断队满：初始时队列为空，两个指针重合，入队rear指针加1，指向队尾元素的下一位置，出队front指针加1，指向队首元素。为区分`Q.front == Q.rear`代表队空还是队满，有三种方式：
1. 牺牲一个单元。队满条件`(Q.rear + 1) % MaxSize == Q.front`
2. 增加记录元素个数的变量。队满条件`Q.size == MaxSize`
3. 增加tag变量。删除元素时tag为0，插入元素tag为1，队满条件`Q.front == Q.rear && tag == 1`

队列的链式存储。

双端队列：两端都可以入队和出队的队列。输入序列1234，输入受限的双端队列不能得到的输出序列是（4231，4213），输出受限的双端队列不能得到的输出序列是（4231，4132）。

**CODING**：王道3.2的3。

### 栈和队列的应用

**表达式运算**。

**后缀表达式转中缀表达式/后缀表达式运算**：
* 一个操作数栈
* 从前往后扫描后缀序列
* 遇到操作数入栈
* 遇到操作符op时，从栈中弹出两个操作数Y和X，组成新数X op Y入栈
* 最后栈顶就是运算结果

**中缀表达式转后缀表达式**：
方法一：
* 一个操作符栈
* 从前往后扫描中缀序列，操作数直接输出，操作符入栈
* 操作符入栈时，弹出栈中同级或高级操作符，直到碰到低级操作符为止，再将该操作符入栈
* `(`直接入栈，只有`)`能弹出它，且`)`入栈时弹出到第一个遇到的`(`之间的所有操作符

方法二：
* 将所有运算按优先级加上括号
* 再将操作符移到每组括号之后
* 去掉括号，得到结果

**中缀表达式运算算法/两个栈的表达式求值算法**（其实和中缀转后缀的方法一规则一样）：
* 两个栈，操作数栈和操作符栈
* 从前往后扫描中缀序列，操作数直接入栈
* 操作符入栈时，弹出栈中同级或高级操作符，并对每个操作符运算（从操作数栈中弹出两个操作数运算后入操作数栈），直到碰到低级操作符为止，再将该操作符入栈
* `(`直接入栈，只有`)`能弹出它，且`)`入栈时弹出到第一个遇到的`(`之间的所有操作符并同上进行运算
* 序列扫描完毕后，不断弹出操作符运算直到结束
* 时间复杂度`O(n)`
* [参考](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962141&idx=1&sn=b089acccefc9e55098833cdc4e95d07f&chksm=bd2d0ec18a5a87d72cd0b72180eb3b433634fb1c2af0db0cd37687135a20bf839525976b8e71&mpshare=1&scene=1&srcid=0423hoFUpZXU8ykhtFB4ek4f#rd)

王道p89选择11，可以用不同的算法运算这个表达式，观察栈的状态。

**CODING**：王道3.3的3。

### 特殊矩阵的压缩存储

对称矩阵：只存放上三角/下三角部分的元素。

三角矩阵：上三角区/下三角区的元素值为同一常量，存储时存储完上/下三角区的元素后，在最后一位存储该常量。

三对角矩阵/带状矩阵：只有中间三条对角线，其余元素为0。

稀疏矩阵：将非零元素的行列坐标和值构成三元组存储，会丢失随机存取特性。

## 树与二叉树

树也是一种逻辑结构。

### 树的基本概念

度：树中一个结点的子结点个数。树中所有结点度数的最大值是树的度。

路径：树中两个结点间所经过的结点序列，所经过的边的个数是路径长度。由于树的分支是有向的，从双亲结点指向孩子节点，因此树中的路径也只能是从上到下的，子结点之间不存在路径。

王道p107：总和总结点数的关系。

### 二叉树的基本概念

特殊的二叉树：
* 满二叉树：每一层都是满的，即都有最大结点个数。
* 完全二叉树：
  * 定义：对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树
  * 叶结点只可能在最大两层出现，且最大层次的叶结点都依次排列在最左边
  * 若有度为1的结点，只能有1个，且该结点之后序号的结点都是叶结点，此时总结点数为偶数，叶结点数与非叶结点数相同
* 二叉排序树：左子树上所有结点的关键字都小于根结点，右子树上所有结点都大于根结点，左右子树也都是二叉排序树。
* 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1。

二叉树的性质（理解）：
* 非空二叉树叶结点个数 = 度为2结点个数 + 1
* 有n个结点的完全二叉树的高度为`ceil(log2(n + 1))`或`floor(log2(n)) + 1`

二叉树的存储结构：
* 顺序存储：对完全二叉树和满二叉树比较合适，对一般二叉树，若也想让下标反应逻辑关系，需要添加空结点
* 链式存储：有n个结点的二叉链表中空链域为n + 1个

### 二叉树的遍历和线索二叉树

PreOrder先序遍历，InOrder中序遍历，PostOrder后序遍历，时间复杂度都是`O(n)`，空间复杂度为递归栈的深度，最坏情况下为`O(n)`。

层次遍历，借助队列。

**由先序/后序/层次遍历序列+中序遍历序列可以唯一确定二叉树**。

线索二叉树：是一种**存储结构**。结点结构中多了两个标志位，当结点无左子树时，ltag = 1，lchild指向该结点的直接前驱，直接后继的rtag、rchild规则相同。

线索二叉树的构造就是按某一遍历顺序，在遍历时填充结点结构中的空指针域。

**线索二叉树的遍历**是按线索访问线索二叉树，和构造不同。先序线索树和中序线索树可以不借助栈实现二叉树遍历，但是后序线索树必须要借助栈才能遍历二叉树（有可能找不到直接后继，王道p125的29，31题）。

**CODING**：王道4.3，p118中序遍历的非递归算法，p119层次遍历，课后题3非递归后序遍历求路径算法1，课后15，课后20。

### 树、森林

树的存储结构：
* 双亲表示法：数组存储，每个元素有两个字段，值和双亲结点的伪指针。
* 孩子表示法：每个结点有一个孩子结点的单链表。
* 孩子兄弟表示法：以二叉链表存储，结点中有指向第一个孩子节点和下一个兄弟结点的指针。

树转换为二叉树：左孩子右兄弟，因此二叉链表表示的树有唯一对应的二叉树。

森林转换为二叉树：先将森林中每一棵树转换为二叉树（此时每棵二叉树的根结点都没有右子树），然后将第一棵树树的根作为转换后二叉树的根，第二棵树作为其右子树，第三棵树作为其右子树的右子树...

二叉树转换为森林：即森林转换为二叉树的逆过程，拆成没有右子树的二叉树，将二叉树的根和左子树作为第一棵树，根的右子树也将其根和左子树作为一棵树...二叉树转换为树和森林是唯一的。

树的遍历：
* 先根遍历：
  * 先访问根结点，再从左到右遍历根结点的每棵子树。
  * 访问顺序与这棵树对应的二叉树的先序遍历顺序相同。
* 后根遍历：
  * 先从左到右顺序遍历根结点的每棵子树，再访问根结点。
  * 访问顺序与对应二叉树的**中序遍历**相同（注意不是后序遍历，举例看一下即知）。

森林的遍历：
* 先序遍历：
  * 先访问森林中第一棵树的根结点，再先序遍历第一棵树根结点的子树森林，再先序遍历剩下树组成的森林。
  * 对应二叉树的先序遍历。
* 中序遍历：
  * 先中序遍历第一棵树根结点的子树森林，再访问第一棵树的根结点，再中序遍历剩下的树组成的森林。
  * 对应二叉树的中序遍历。

并查集：一种集合的表示，常用树/森林的**双亲表示法**作为其存储结构，将数组下标作为元素名，字段内容为双亲结点的下表，根结点的双亲结点为负。

查并集的基本操作：
* Initial：数组内容全初始化为-1
* Find：从x开始向前找双亲结点，直到找到值为负的就是根结点
* Union：合并集合，将一个集合的根结点的指针指向另一个集合的根结点即可。

### 树与二叉树的应用

#### 二叉排序树

定义：左子树所有结点都小于根结点，右子树所有结点都大于根结点，且左右子树也分别是二叉排序树。

基本操作：
* 查找
* 插入
* 构造：依次执行插入
* 删除：有几种情况
  * 删除叶结点：直接删除
  * 删除结点只有左/右子树：让子树代替该结点
  * 删除节点有左、右两棵子树：用该结点的**直接后继或直接前驱**替代它，并删掉这个替代的结点（也就是用顺序排列中该结点的紧邻前后结点替代它）

#### 平衡二叉树

定义：任意结点左右子树的高度差的绝对值不超过1的**二叉排序树**。也叫AVL平衡树。

**平衡因子**：结点左子树和右子树的高度差为该结点的平衡因子。由定义，平衡二叉树每个结点的平衡因子只能是-1、0或1。

理解定义，平衡因子的绝对值不能超过1，但叶子结点的最大深度差可以超过1。

构造h层平衡二叉树所需的最小结点数的递推公式：`C(h) = C(h-1) + C(h-2) + 1`其中`C(1) = 1, C(2) = 2`。思想：新建一个根结点，连接h-1层和h-2层两棵平衡二叉树，得到h层平衡二叉树。（王道p166的13，17）

**平衡二叉树插入**：若插入导致了不平衡，找到**插入路径上离插入结点最近的不平衡结点A**，对**以A为根的子树**进行如下四种之一的操作：
* LL平衡旋转/右单旋转：在A的左孩子的左子树上插入，向右旋转一次。
* RR平衡旋转/左单旋转：在A的右孩子的右子树上插入，向左旋转一次。
* LR平衡旋转/先左后右双旋转：在A的左孩子的右子树上插入，先将A左孩子为根的子树左旋转，再将A为根子树右旋转，最后A左孩子的右子树的根结点C提升到A的位置。
* RL平衡旋转/先右后左双旋转：即LR方向反过来进行两次旋转。
* 在旋转过程中还要注意**旋转到根位置结点的子结点的移动**：为保持二叉排序树的性质，一个结点向右旋转成为根结点时，它原来的右结点要移动成为旧根结点的左子结点，这在LL/RR中可能出现一次，在LR/RL中可能出现两次，且尤其要注意LR/RL中只出现一次的情况（即C只有一个左/右孩子，王道p166选择16）。

#### 哈夫曼树

权：树中节点被赋予的数值，权值。

带权路径长度：树根结点到任意结点的路径长度（经过的边数）与该结点上权值的乘积。树中所有结点的带权路径长度之和叫树的带权路径长度（WPL）。

哈夫曼树/最优二叉树：含有n个带权叶子结点的**二叉树**中，WPL最小的**二叉树**。

哈夫曼树的构造：
* 构造步骤：
  * 将n个结点每个看成一棵树
  * 选择权值和最小的两棵树组成新树，直到只有一棵树为止
* 初始结点最后都成为叶结点，非叶结点没有权值
* 构造过程中供新建了n - 1个结点，哈夫曼树共2n - 1个结点
* 哈夫曼树中没有度为1的结点

哈夫曼编码：在哈夫曼树的路径上标0或1，是一种可变长度的前缀编码，即没有一个编码是另一个编码的前缀。

哈夫曼树的WPL是对应哈夫曼编码的二进制长度，它是总长度最短的二进制前缀编码。理解哈夫曼编码的作用，要求哈夫曼树是二叉树，对应了哈夫曼编码的二进制编码，要求哈夫曼树的WPL最小，对应了哈夫曼编码的编码长度最短。

**CODING**：王道p179。

## 图

### 图的基本概念

有向图：有向图的边称为弧，即顶点的有序对`<v, w>`，其中v是**弧尾**，w是**弧头**。

无向图。

简单图：不存在重复边，不存在顶点到自身的边，这里只讨论简单图。

完全图：
* 无向完全图：无向图中任意两个顶点之间都存在边。
* 有向完全图：有向图中任意两个顶点之间都存在两条方向相反的弧。

子图。注意顶点的子集和边的子集要配套才能构成子图。

无向图中：
* 连通：无向图中两顶点之间有路径存在，则称它们连通。
* 连通图：无向图任意两顶点连通，则该无向图是连通图。
* **连通分量**：无向图中的极大连通子图。若无向图非连通，就有多个连通分量。

有向图中：
* 强连通：任意两点间有路径，则称它们强连通。
* 强连通图：有向图任意两顶点强连通，则该有向图是强连通图。
* 强连通分量：有向图中的极大强连通子图。

**生成树**：包含全部顶点的**极小连通子图**。生成树是对**连通图**而言的。非连通图的连通分量的生成树构成了生成森林。

**极大连通子图**和**极小连通子图**：极大指边数极大，包含原连通图的所有和子图顶点有关的边；极小指边数极小，包含了能使子图连通的最少的边。

度，入度，出度。

网/带权图：边上带有权值的图。

路径：两顶点间的顶点序列，包含起止顶点。路径上边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路。

简单路径：路径序列中顶点不重复出现。

距离：顶点间最短路径的长度。

### 图的存储和基本操作

### 图的遍历

### 图的应用

#### 最小生成树算法

**Prim算法**

**Kruskal算法**

#### 最短路径

**Dijkstra算法**

#### **拓扑排序**

#### **关键路径**



## 查找

### 基本概念

### 顺序查找和折半查找

#### **顺序查找**

#### **折半查找**

#### 分块查找

### B树和B+树

#### **B树**

#### **B+树**

### 散列表

#### **散列查找**

### 串

#### **经典模式匹配算法/BF算法**

#### **KMP算法**



## 排序

### 基本概念

### 插入排序

#### **直接插入排序**

#### **折半插入排序**

#### **希尔排序**

### 交换排序

#### **冒泡排序**

#### **快速排序**

### 选择排序

#### **简单选择排序**

#### **堆排序**

### 归并排序和基数排序

#### **归并排序**

#### **基数排序**

### 内部排序算法的比较和应用

### 外部排序


* “王道”指王道2020数据结构复习指导

## 绪论

区分**数据的逻辑结构和存储结构**。

逻辑结构：
* 线性结构：
  * 一般线性表
  * 受限线性表：栈、队列
  * 线性表推广：数组、广义表
* 非线性结构：
  * 集合
  * 树形结构
  * 图或网

存储结构/物理结构：
* 顺序存储
* 链式存储
* 索引存储
* 散列存储/哈希

时间复杂度：算法中基本语句（最内层循环语句）执行次数的数量级，O表示数量级。

空间复杂度：算法消耗的辅助空间的数量级，O(1)表示算法原地工作，指算法需要的辅助空间为常量。

**分析时间复杂度的方法**：
* 若循环主体中的变量参与循环条件的判断：将变量代入循环条件计算
* 若循环主题变量与循环条件无关：
  * 程序是递归的：递推
  * 程序非递归：累次求和

## 线性表

### 线性表的定义和基本操作

线性表是具有相同数据类型n个元素的**有限**序列。线性表中元素有先后顺序。

### 线性表的顺序表示

即线性表这个逻辑结构的顺序存储方式，又叫顺序表。即数组。

基本操作：
* 插入：将所有后面元素向后移，平均时间复杂度为`O(n)`
* 删除：平均时间复杂度`O(n)`
* 按值查找/顺序查找：平均时间复杂度`O(n)`

**CODING**：王道2.2的3，8，11，12，13。

### 线性表的链式表示

头指针和头结点：头结点让对链表所有结点的操作统一，而头指针在有头结点时指向头结点，没有头结点时指向第一个数据结点。

单链表基本操作：
* 创建链表：头插法或尾插法，时间复杂度都是`O(n)`
* 按序号查找：即访问第i个结点，时间复杂度`O(n)`
* 按值查找：时间复杂度`O(n)`
* 插入：若不包含查找（给定插入位置的前一结点指针），时间复杂度`O(1)`
* 删除：若不包含查找，时间复杂度`O(1)`。另，若给定一结点指针要删除它，不必从头查找它的前一结点，可通过复制后一结点值再删除后一结点实现。

双链表。

循环链表。

静态链表：用数组描述链表，结点的next字段存储的是下一结点的数组下标。

顺序或链式存储的查找时，要区分**按值查找**和**按序号查找**（王道p34）。

**CODING**：王道2.3的5，22。

## 栈和队列

首先，栈和队列属于逻辑结构中的线性表。

### 栈

栈的实现：
* 顺序存储结构：
  * 顺序栈
  * 共享栈：两个栈底分别在共享空间的两端，当栈顶指针相邻时栈满，可以降低上溢可能。
* 链式存储结构

**Catlan卡特兰数**：n个元素以固定顺序进栈，进栈过程中可以出栈，共有不同出栈序列的个数为

$$
C\tbinom{n}{2n} / (n + 1)
$$

采用分治递归的思想，设第k个元素固定在第k位出栈，它分割前后两组元素的顺序个数也分别独立是卡特兰数。王道p63选择11，25。

### 队列

队头：删除元素的一端；队尾：插入元素的一端。注意是从队尾入队的。

队列的顺序存储：可能出现**上溢出**，数组中仍有空间但两个指针都指向数组末尾。为避免上溢出的缺点，引入了循环队列。

#### **循环队列**

循环队列的关键操作的描述按照王道来，但考题会很严格地给出，不一定按王道。

初始状态：`Q.front = Q.rear = 0`

队列长度：`(Q.rear - Q.front + MaxSize) % MaxSize`

出队入队：`Q.rear = (Q.rear + 1) % MaxSize; //入队 Q.front = (Q.front + 1) % MaxSize // 出队`，两个指针都按顺时针方向进1。

判断队空：`Q.front == Q.rear`，即两个指针重合。

判断队满：初始时队列为空，两个指针重合，入队rear指针加1，指向队尾元素的下一位置，出队front指针加1，指向队首元素。为区分`Q.front == Q.rear`代表队空还是队满，有三种方式：
1. 牺牲一个单元。队满条件`(Q.rear + 1) % MaxSize == Q.front`
2. 增加记录元素个数的变量。队满条件`Q.size == MaxSize`
3. 增加tag变量。删除元素时tag为0，插入元素tag为1，队满条件`Q.front == Q.rear && tag == 1`

队列的链式存储。

双端队列：两端都可以入队和出队的队列。输入序列1234，输入受限的双端队列不能得到的输出序列是（4231，4213），输出受限的双端队列不能得到的输出序列是（4231，4132）。

**CODING**：王道3.2的3。

### 栈和队列的应用

**表达式运算**。

**后缀表达式转中缀表达式/后缀表达式运算**：
* 一个操作数栈
* 从前往后扫描后缀序列
* 遇到操作数入栈
* 遇到操作符op时，从栈中弹出两个操作数Y和X，组成新数X op Y入栈
* 最后栈顶就是运算结果

**中缀表达式转后缀表达式**：
方法一：
* 一个操作符栈
* 从前往后扫描中缀序列，操作数直接输出，操作符入栈
* 操作符入栈时，弹出栈中同级或高级操作符，直到碰到低级操作符为止，再将该操作符入栈
* `(`直接入栈，只有`)`能弹出它，且`)`入栈时弹出到第一个遇到的`(`之间的所有操作符

方法二：
* 将所有运算按优先级加上括号
* 再将操作符移到每组括号之后
* 去掉括号，得到结果

**中缀表达式运算算法/两个栈的表达式求值算法**（其实和中缀转后缀的方法一规则一样）：
* 两个栈，操作数栈和操作符栈
* 从前往后扫描中缀序列，操作数直接入栈
* 操作符入栈时，弹出栈中同级或高级操作符，并对每个操作符运算（从操作数栈中弹出两个操作数运算后入操作数栈），直到碰到低级操作符为止，再将该操作符入栈
* `(`直接入栈，只有`)`能弹出它，且`)`入栈时弹出到第一个遇到的`(`之间的所有操作符并同上进行运算
* 序列扫描完毕后，不断弹出操作符运算直到结束
* 时间复杂度`O(n)`
* [参考](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962141&idx=1&sn=b089acccefc9e55098833cdc4e95d07f&chksm=bd2d0ec18a5a87d72cd0b72180eb3b433634fb1c2af0db0cd37687135a20bf839525976b8e71&mpshare=1&scene=1&srcid=0423hoFUpZXU8ykhtFB4ek4f#rd)

王道p89选择11，可以用不同的算法运算这个表达式，观察栈的状态。

**CODING**：王道3.3的3。

### 特殊矩阵的压缩存储

对称矩阵：只存放上三角/下三角部分的元素。

三角矩阵：上三角区/下三角区的元素值为同一常量，存储时存储完上/下三角区的元素后，在最后一位存储该常量。

三对角矩阵/带状矩阵：只有中间三条对角线，其余元素为0。

稀疏矩阵：将非零元素的行列坐标和值构成三元组存储，会丢失随机存取特性。

## 树与二叉树

树也是一种逻辑结构。

### 树的基本概念

度：树中一个结点的子结点个数。树中所有结点度数的最大值是树的度。

路径：树中两个结点间所经过的结点序列，所经过的边的个数是路径长度。由于树的分支是有向的，从双亲结点指向孩子节点，因此树中的路径也只能是从上到下的，子结点之间不存在路径。

王道p107：总和总结点数的关系。

### 二叉树的基本概念

特殊的二叉树：
* 满二叉树：每一层都是满的，即都有最大结点个数。
* 完全二叉树：
  * 定义：对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树
  * 叶结点只可能在最大两层出现，且最大层次的叶结点都依次排列在最左边
  * 若有度为1的结点，只能有1个，且该结点之后序号的结点都是叶结点，此时总结点数为偶数，叶结点数与非叶结点数相同
* 二叉排序树：左子树上所有结点的关键字都小于根结点，右子树上所有结点都大于根结点，左右子树也都是二叉排序树。
* 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1。

二叉树的性质（理解）：
* 非空二叉树叶结点个数 = 度为2结点个数 + 1
* 有n个结点的完全二叉树的高度为`ceil(log2(n + 1))`或`floor(log2(n)) + 1`

二叉树的存储结构：
* 顺序存储：对完全二叉树和满二叉树比较合适，对一般二叉树，若也想让下标反应逻辑关系，需要添加空结点
* 链式存储：有n个结点的二叉链表中空链域为n + 1个

### 二叉树的遍历和线索二叉树

PreOrder先序遍历，InOrder中序遍历，PostOrder后序遍历，时间复杂度都是`O(n)`，空间复杂度为递归栈的深度，最坏情况下为`O(n)`。

层次遍历，借助队列。

**由先序/后序/层次遍历序列+中序遍历序列可以唯一确定二叉树**。

线索二叉树：结点结构中多了两个标志位，当结点无左子树时，ltag = 1，lchild指向该结点的直接前驱，直接后继的规则相同。

**CODING**：王道4.3，中序遍历的非递归算法，层次遍历。

### 树、森林

### 树与二叉树的应用




## 图

### 图的基本概念

### 图的存储和基本操作

### 图的遍历

### 图的应用

#### 最小生成树算法

**Prim算法**

**Kruskal算法**

#### 最短路径

**Dijkstra算法**

#### **拓扑排序**

#### **关键路径**



## 查找

### 基本概念

### 顺序查找和折半查找

#### **顺序查找**

#### **折半查找**

#### 分块查找

### B树和B+树

#### **B树**

#### **B+树**

### 散列表

#### **散列查找**

### 串

#### **经典模式匹配算法/BF算法**

#### **KMP算法**



## 排序

### 基本概念

### 插入排序

#### **直接插入排序**

#### **折半插入排序**

#### **希尔排序**

### 交换排序

#### **冒泡排序**

#### **快速排序**

### 选择排序

#### **简单选择排序**

#### **堆排序**

### 归并排序和基数排序

#### **归并排序**

#### **基数排序**

### 内部排序算法的比较和应用

### 外部排序

